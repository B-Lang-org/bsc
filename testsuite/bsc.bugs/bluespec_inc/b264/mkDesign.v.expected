//
// Generated by Bluespec Compiler
//
//
// Ports:
// Name                         I/O  size props
// result_adder1                  O     1 reg
// result_adder2                  O     1 reg
// clk                            I     1 clock
// reset                          I     1 reset
// calc_aa                        I     1 reg
// calc_ab                        I     1 reg
// calc_ba                        I     1 reg
// calc_bb                        I     1 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkDesign(clk,
		reset,

		calc_aa,
		calc_ab,
		calc_ba,
		calc_bb,

		result_adder1,

		result_adder2);
  input  clk;
  input  reset;

  // action method calc
  input  calc_aa;
  input  calc_ab;
  input  calc_ba;
  input  calc_bb;

  // value method result_adder1
  output result_adder1;

  // value method result_adder2
  output result_adder2;

  // signals for module outputs
  wire result_adder1, result_adder2;

  // register i_a0
  reg i_a0;
  wire i_a0$D_IN, i_a0$EN;

  // register i_a1
  reg i_a1;
  wire i_a1$D_IN, i_a1$EN;

  // register i_b0
  reg i_b0;
  wire i_b0$D_IN, i_b0$EN;

  // register i_b1
  reg i_b1;
  wire i_b1$D_IN, i_b1$EN;

  // register i_res1
  reg i_res1;
  wire i_res1$D_IN, i_res1$EN;

  // register i_res2
  reg i_res2;
  wire i_res2$D_IN, i_res2$EN;

  // value method result_adder1
  assign result_adder1 = i_res1 ;

  // value method result_adder2
  assign result_adder2 = i_res2 ;

  // register i_a0
  assign i_a0$D_IN = calc_aa ;
  assign i_a0$EN = 1'd1 ;

  // register i_a1
  assign i_a1$D_IN = calc_ab ;
  assign i_a1$EN = 1'd1 ;

  // register i_b0
  assign i_b0$D_IN = calc_ba ;
  assign i_b0$EN = 1'd1 ;

  // register i_b1
  assign i_b1$D_IN = calc_bb ;
  assign i_b1$EN = 1'd1 ;

  // register i_res1
  assign i_res1$D_IN = i_a0 ^ i_a1 ;
  assign i_res1$EN = 1'd1 ;

  // register i_res2
  assign i_res2$D_IN = i_b0 ^ i_b1 ;
  assign i_res2$EN = 1'd1 ;

  // handling of inlined registers

  always@(posedge clk)
  begin
    if (reset == `BSV_RESET_VALUE)
      begin
        i_a0 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i_a1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i_b0 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i_b1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i_res1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	i_res2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (i_a0$EN) i_a0 <= `BSV_ASSIGNMENT_DELAY i_a0$D_IN;
	if (i_a1$EN) i_a1 <= `BSV_ASSIGNMENT_DELAY i_a1$D_IN;
	if (i_b0$EN) i_b0 <= `BSV_ASSIGNMENT_DELAY i_b0$D_IN;
	if (i_b1$EN) i_b1 <= `BSV_ASSIGNMENT_DELAY i_b1$D_IN;
	if (i_res1$EN) i_res1 <= `BSV_ASSIGNMENT_DELAY i_res1$D_IN;
	if (i_res2$EN) i_res2 <= `BSV_ASSIGNMENT_DELAY i_res2$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    i_a0 = 1'h0;
    i_a1 = 1'h0;
    i_b0 = 1'h0;
    i_b1 = 1'h0;
    i_res1 = 1'h0;
    i_res2 = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkDesign

