//
// Generated by Bluespec Compiler
//
//
// Ports:
// Name                         I/O  size props
// done                           O     1 reg
// product                        O     8 reg
// clk                            I     1 clock
// reset                          I     1 reset
// shift_and_add_a                I     4
// shift_and_add_b                I     4
// shift_and_add_load             I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkDesign(clk,
		reset,

		shift_and_add_a,
		shift_and_add_b,
		shift_and_add_load,

		done,

		product);
  input  clk;
  input  reset;

  // action method shift_and_add
  input  [3 : 0] shift_and_add_a;
  input  [3 : 0] shift_and_add_b;
  input  shift_and_add_load;

  // value method done
  output done;

  // value method product
  output [7 : 0] product;

  // signals for module outputs
  wire [7 : 0] product;
  wire done;

  // register i_acc
  reg [7 : 0] i_acc;
  wire [7 : 0] i_acc$D_IN;
  wire i_acc$EN;

  // register i_count
  reg [3 : 0] i_count;
  wire [3 : 0] i_count$D_IN;
  wire i_count$EN;

  // register i_done_reg
  reg i_done_reg;
  wire i_done_reg$D_IN, i_done_reg$EN;

  // register i_enable
  reg i_enable;
  wire i_enable$D_IN, i_enable$EN;

  // register i_mult
  reg [3 : 0] i_mult;
  wire [3 : 0] i_mult$D_IN;
  wire i_mult$EN;

  // register i_multiplicand
  reg [7 : 0] i_multiplicand;
  wire [7 : 0] i_multiplicand$D_IN;
  wire i_multiplicand$EN;

  // remaining internal signals
  wire [7 : 0] x__h508, x__h592, x__h741;
  wire [3 : 0] x__h704, x__h778;

  // value method done
  assign done = i_done_reg ;

  // value method product
  assign product = i_acc ;

  // register i_acc
  assign i_acc$D_IN =
	     (shift_and_add_load && i_count == 4'd0) ?
	       8'd0 :
	       (i_mult[0] ? x__h508 : i_acc) ;
  assign i_acc$EN =
	     shift_and_add_load && i_count == 4'd0 ||
	     i_enable && i_count != 4'd4 ;

  // register i_count
  assign i_count$D_IN =
	     (shift_and_add_load && i_count == 4'd0) ?
	       4'd0 :
	       ((i_enable && i_count != 4'd4) ? x__h778 : 4'd0) ;
  assign i_count$EN = 1'd1 ;

  // register i_done_reg
  assign i_done_reg$D_IN =
	     (!shift_and_add_load || i_count != 4'd0) &&
	     (!i_enable || i_count == 4'd4) ;
  assign i_done_reg$EN = 1'd1 ;

  // register i_enable
  assign i_enable$D_IN = shift_and_add_load && i_count == 4'd0 ;
  assign i_enable$EN =
	     shift_and_add_load && i_count == 4'd0 || !i_enable ||
	     i_count == 4'd4 ;

  // register i_mult
  assign i_mult$D_IN =
	     (shift_and_add_load && i_count == 4'd0) ?
	       shift_and_add_b :
	       x__h704 ;
  assign i_mult$EN =
	     shift_and_add_load && i_count == 4'd0 ||
	     i_enable && i_count != 4'd4 ;

  // register i_multiplicand
  assign i_multiplicand$D_IN =
	     (shift_and_add_load && i_count == 4'd0) ? x__h592 : x__h741 ;
  assign i_multiplicand$EN =
	     shift_and_add_load && i_count == 4'd0 ||
	     i_enable && i_count != 4'd4 ;

  // remaining internal signals
  assign x__h508 = i_acc + i_multiplicand ;
  assign x__h592 = { 4'b0, shift_and_add_a } ;
  assign x__h704 = { 1'd0, i_mult[3:1] } ;
  assign x__h741 = { i_multiplicand[6:0], 1'd0 } ;
  assign x__h778 = i_count + 4'd1 ;

  // handling of inlined registers

  always@(posedge clk)
  begin
    if (reset == `BSV_RESET_VALUE)
      begin
        i_acc <= `BSV_ASSIGNMENT_DELAY 8'd0;
	i_count <= `BSV_ASSIGNMENT_DELAY 4'd0;
	i_enable <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (i_acc$EN) i_acc <= `BSV_ASSIGNMENT_DELAY i_acc$D_IN;
	if (i_count$EN) i_count <= `BSV_ASSIGNMENT_DELAY i_count$D_IN;
	if (i_enable$EN) i_enable <= `BSV_ASSIGNMENT_DELAY i_enable$D_IN;
      end
    if (i_mult$EN) i_mult <= `BSV_ASSIGNMENT_DELAY i_mult$D_IN;
    if (i_multiplicand$EN)
      i_multiplicand <= `BSV_ASSIGNMENT_DELAY i_multiplicand$D_IN;
  end

  always@(posedge clk or `BSV_RESET_EDGE reset)
  if (reset == `BSV_RESET_VALUE)
    begin
      i_done_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
    end
  else
    begin
      if (i_done_reg$EN) i_done_reg <= `BSV_ASSIGNMENT_DELAY i_done_reg$D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    i_acc = 8'hAA;
    i_count = 4'hA;
    i_done_reg = 1'h0;
    i_enable = 1'h0;
    i_mult = 4'hA;
    i_multiplicand = 8'hAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkDesign

